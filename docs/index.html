<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>
  cpphs
</title>
</head>
 
<body bgcolor='#ffffff'>

<center>
<h1>cpphs</h1>
<table><tr><td width=200 align=center>
<a href="#what">What is cpphs?</a><br>
<a href="#how">How do I use it?</a><br>
<a href="#download">Downloads</a><br>
</td><td width=200 align=center>
<a href="#diff">Differences to cpp</a><br>
<a href="#who">Contacts</a><br>
</td></tr></table>
</center>
<hr>

<center><h3><a name="what">What is cpphs?</a></h3></center>
<p>
<b>cpphs</b> is a simplified re-implementation of cpp,
the C pre-processor, in Haskell.

<p>
Why re-implement cpp?  Rightly or wrongly, the C pre-processor is
widely used in Haskell source code.  It enables conditional compilation
for different compilers, different versions of the same compiler,
and different OS platforms.  It is also occasionally used for its
macro language, which can enable certain forms of platform-specific
detail-filling, such as the tedious boilerplate generation of instance
definitions and FFI declarations.  However, there are two problems with
cpp, aside from the obvious aesthetic ones:
<ul>
  <li> For some Haskell systems, notably Hugs on Windows, a true cpp
       is not available by default.
  <li> Even for the other Haskell systems, the common cpp provided by
       the gcc 3.x series is changing subtly in ways that are
       incompatible with Haskell's syntax.  There have always been
       problems with, for instance, string gaps, and prime characters
       in identifiers.  These problems are only going to get worse.
</ul>
So, it seemed right to attempt to provide an alternative to cpp,
both more compatible with Haskell, and itself written in Haskell so
that it can be distributed with compilers.

<p>
This version of the C pre-processor is pretty-much feature-complete.
It has two modes:
<ul>
  <li> conditional compilation only (--nomacro),
  <li> and full macro-expansion (default).
</ul>
In <tt>--nomacro</tt> mode, cpphs performs only conditional
compilation actions, namely <tt>#include</tt>'s, <tt>#if</tt>'s, and
<tt>#ifdef</tt>'s are processed according to symbol definitions (both
command-line and internal), but no symbol replacement or parameterised
macro expansion is performed.  In full compatibility mode (the
default), symbol replacements and macro expansions are also processed.

<p>
Working Features:
<dl>
<dt>#ifdef</dt>	 <dd>simple conditional compilation</dd>
<dt>#if</dt>	 <dd>the full boolean language of defined(),
                     &amp;&amp;, ||, ==, etc.</dd>
<dt>#elif</dt>	 <dd>chained conditionals</dd>
<dt>#define</dt> <dd>in-line definitions (symbols and macros)</dd>
<dt>#undef</dt>	 <dd>in-line revocation of definitions</dd>
<dt>#include</dt><dd>file inclusion</dd>
<dt>#line</dt>   <dd>line number directives</dd>
<dt>\\n</dt>     <dd>line continuations within all # directives</dd>
<dt>## /**/</dt> <dd>token catenation within a macro definition</dd>
</dl>

<p>
Macro expansion is recursive.  Redefinition of a macro or symbol does
not generate a warning.  Macros can be defined on the command-line
with -D just like symbols.  Macro/symbol names are permitted to be
Haskell identifiers e.g. with the ' character, which is slightly
looser than in C, but they still may not include operators.

<p>
Numbering of lines in the output is preserved so that any later
processor can give meaningful error messages.  When a file is
<tt>#include</tt>'d, cpphs inserts <tt>#line</tt> directives for the
same reason.  Numbering should be correct even in the presence of
line continuations.  If you don't want <tt>#line</tt> directives in
the final output, use the <tt>--noline</tt> option.


<p>
Any syntax errors in cpp directives, and any failure to find a
#include'd file, gives a message to standard error and halts the
program.

<hr>
<center><h3><a name="how">How do I use it?</a></h3></center>
<p>
<center><pre>
Usage: cpphs  [ filename | -Dsym | -Dsym=val | -Ipath ]+
              [--nomacro] [--noline] [--strip] [--stringise]
</pre></center>
<p>
You can give any number of filenames on the command-line.  The
results are catenated on standard output.

<p>
Options:
<dl>
<dt>-Dsym</dt>    <dd>define a symbol</dd>
<dt>-Dsym=val</dt><dd>define a symbol with a specific value</dd>
<dt>-Ipath</dt>   <dd>add a directory to the search path for #include's</dd>
<dt>--nomacro</dt><dd>only process #ifdef's and #include's,
                      do not expand macros</dd>
<dt>--noline</dt> <dd>remove #line droppings from the output</dd>
<dt>--strip</dt>  <dd>convert C-style comments to whitespace, even outside
                      cpp directives</dd>
<dt>--stringise</dt><dd>recognise the # stringise operator within macros</dd>
</dl>

<p>
There are NO symbols defined by default.  (This could easily be
changed in the source code.)  The search path is searched in
order of the -I options, except that the current directory is always
searched first.  Again, there is no default search path (and again,
this could easily be changed).


<hr>
<center><h3><a name="download">Downloads</a></h3></center>
<p>
<b>Current version:</b>
<p>
cpphs-0.3, release date 2004.05.18<br>
By HTTP:
<a href="http://www.cs.york.ac.uk/fp/cpphs/cpphs-0.3.tar.gz">.tar.gz</a>,
<a href="http://www.cs.york.ac.uk/fp/cpphs/cpphs-0.3.zip">.zip</a>.
<p>
Fix recursive macro expansion bug.  Added option to strip C comments.
Added option to recognise the # stringise operator.

<p>
<b>Older versions:</b>
<p>
cpphs-0.2, release date 2004.05.15<br>
By HTTP:
<a href="http://www.cs.york.ac.uk/fp/cpphs/cpphs-0.2.tar.gz">.tar.gz</a>,
<a href="http://www.cs.york.ac.uk/fp/cpphs/cpphs-0.2.zip">.zip</a>.
<p>
Implements textual replacement and macro expansion.
<p>
cpphs-0.1, release date 2004.04.07<br>
By HTTP:
<a href="http://www.cs.york.ac.uk/fp/cpphs/cpphs-0.1.tar.gz">.tar.gz</a>,
<a href="http://www.cs.york.ac.uk/fp/cpphs/cpphs-0.1.zip">.zip</a>.
<p>
Initial release: implements conditional compilation and file inclusion only.


<p>
To build cpphs, use
<pre>    hmake cpphs [-package base]
</pre>
or
<pre>    ghc --make cpphs
</pre>
or
<pre>    runhugs cpphs
</pre>


<hr>
<center><h3><a name="diff">Differences from cpp</a></h3></center>
<p>
In general, cpphs is based on the <tt>-traditional</tt> behaviour, not
ANSI C, and has the following main differences from the standard cpp.

<p>
<b>General</b>
<ul>
<li> The <tt>#</tt> that introduces any cpp directive must be in the first
     column of a line (whereas ANSI permits whitespace before the #).
<li> Generates the <tt>#line n "filename"</tt> syntax, not the <tt># n
     "filename"</tt> variant.
<li> C comments are only removed from within cpp directives.  They are
     not stripped from other text.  Consider for instance that in
     Haskell, all of the following are valid operator symbols:  <tt>/*
     */  */*</tt>   However, you can turn on C-comment removal with the
     <tt>--strip</tt> option.
</ul>
<p>
<b>Macro language</b>
<ul>
<li> Accepts both <tt>##</tt> and <tt>/**/</tt> for token-pasting in
     a macro definition.  (Cpp accepts the former only in ANSI mode,
     the latter only in -traditional mode.)  However, <tt>/* */</tt>
     (with any text between the open/close comment) inserts whitespace.
<li> Replaces a macro formal parameter with the actual, even inside a
     string (double or single quoted).  This is -traditional behaviour,
     not supported in ANSI.
<li> Does not recognise the <tt>#</tt> stringisation operator in a macro
     definition, unless you use the <tt>--stringise</tt> option.  (It is
     an ANSI addition, only needed because quoted stringisation (above)
     is prohibited.)
<li> Preserves whitespace within a textual replacement definition
     exactly, but leading and trailing space is eliminated.
<li> Preserves whitespace within a macro definition (and trailing it)
     exactly, but leading space is eliminated.
<li> Preserves whitespace within macro call arguments exactly, but
     leading and trailing space is eliminated.
<li> Line continuations in a macro definition are preserved as
     line-breaks in the macro call.  (Useful for layout-sensitive
     code in Haskell.)
<li> In a macro definition, whitespace is permitted between any of the
     initial name/argument/bracket/comma tokens.  (In cpp, there can be
     no space between the name and the opening bracket.)
</ul>

<hr>
<center><h3><a name="who">Contacts</a></h3></center>
<p>
I am interested in hearing your feedback on cpphs.  Bug reports
especially welcome, since it is so new.  You can send feature requests
too, but I won't guarantee to implement them if they depart much from
the ordinary cpp's behaviour.  Please mail
<ul>
<li>    <a href="mailto:Malcolm.Wallace@cs.york.ac.uk">
        Malcolm.Wallace@cs.york.ac.uk</a> 
</ul>

<p><b>Copyright:</b> &copy; 2004 Malcolm Wallace,
except for ParseLib (Copyright &copy; 1995 Graham Hutton and Erik Meijer)

<p><b>License:</b> The library modules in cpphs are distributed under
the terms of the LGPL (see file <a href="LICENCE-LGPL">LICENCE-LGPL</a>
for more details).  If that's a problem for you, contact me to make
other arrangements.

<p>
The application module 'cpphs.hs' itself is trivial (since all
the functionality is inside the library) and so is placed into the
public domain.

<p>
This software comes with no warranty.  Use at your own risk.

<hr>
 
</body>
</html>
